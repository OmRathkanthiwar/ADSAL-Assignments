import java.util.Scanner;
import java.util.Queue;
import java.util.ArrayDeque;

class BSTNode {
    int data;
    BSTNode leftChild;
    BSTNode rightChild;

    public BSTNode() {
        leftChild = null;
        rightChild = null;
    }
}

public class BST{
    BSTNode root;

    public BST() {
        root = null;
    }

    BSTNode insert(BSTNode root, int data)
    {
        if(root == null)
        {
            root = new BSTNode();
            root.data = data;
            return root;
        }
        if(data == root.data)
        {
            System.out.println("Duplicate key - insertion not allowed");
            return root;
        }
        if(data<root.data)
        {
            root.leftChild = insert(root.leftChild, data);
        }
        else{
            root.rightChild = insert(root.rightChild, data);
        }
        return root;
    }

    void search(BSTNode root, int key)
    {
        if(root == null)
        {
            System.out.println("Tree is empty");
            return;
        }
        BSTNode p = root;
        while(p!=null)
        {
            if(key == p.data)
            {
                System.out.println("Key found");
                return;
            }
            else if(key<p.data)
            {
                p = p.leftChild;
            }
            else {
                p = p.rightChild;
            }
        }
        System.out.println("Key not found");
    }

    void inorder(BSTNode root) {
        if (root != null) {
            inorder(root.leftChild);
            System.out.print(root.data + " ");
            inorder(root.rightChild);
        }
    }

    void preorder(BSTNode root)
    {
        if(root != null)
        {
            System.out.print(root.data + " ");
            preorder(root.leftChild);
            preorder(root.rightChild);
        }
    }

    void postorder(BSTNode root)
    {
        if(root != null)
        {
            postorder(root.leftChild);
            postorder(root.rightChild);
            System.out.print(root.data + " ");

        }
    }

    void levelorder(BSTNode root)
    {
        if (root == null)
            return;

        Queue<BSTNode> q = new ArrayDeque<>();
        q.offer(root);

        while (!q.isEmpty()) {
            BSTNode node = q.poll();
            System.out.print(node.data + " ");

            if (node.leftChild != null)
                q.offer(node.leftChild);

            if (node.rightChild != null)
                q.offer(node.rightChild);
        }
    }

    void mirror(BSTNode root)
    {
        if(root == null)
        {
            return;
        }
        BSTNode temp = root.leftChild;
        root.leftChild = root.rightChild;
        root.rightChild = temp;

        mirror(root.leftChild);
        mirror(root.rightChild);
    }

    BSTNode copyTree(BSTNode root)
    {
        if(root == null)
        {
            return null;
        }
        BSTNode temp = new BSTNode();
        temp.data = root.data;
        temp.leftChild = copyTree(root.leftChild);
        temp.rightChild = copyTree(root.rightChild);
        return temp;
    }

    int height(BSTNode root)
    {
        if(root == null)
        {
            return 0;
        }
        int leftHeight = height(root.leftChild);
        int rightHeight = height(root.rightChild);
        return 1 + Math.max(leftHeight, rightHeight);
    }

    void delete(BSTNode root, int key)
    {
        if(root == null)
        {
            System.out.println("Tree is empty");
            return;
        }
        BSTNode ptr = new BSTNode();
        ptr = root;
        BSTNode parent = new BSTNode();
        parent = null;
        while(ptr != null && ptr.data != key)
        {
            parent  = ptr;
            if(key<ptr.data)
            {
                ptr = ptr.leftChild;
            }
            else
            {
                ptr = ptr.rightChild;
            }
        }
        if(ptr == null)
        {
            System.out.println("Key not found");
            return;
        }
        if(ptr.leftChild == null && ptr.rightChild == null)
        {
            if (parent == null)
            {
                root = null;
            }
            else if (parent.leftChild == ptr)
            {
                parent.leftChild = null;
            }
            else
            {
                parent.rightChild = null;
            }
        }
        if(ptr.leftChild == null || ptr.rightChild == null)
        {
            BSTNode child = new BSTNode();
            if(ptr.leftChild != null)
            {
                child = ptr.leftChild;
            }
            else
            {
                child = ptr.rightChild;
            }
            if(parent == null)
            {
                root = child;
            } else if (parent.leftChild == ptr)
            {
                parent.leftChild = child;
            }
            else
            {
                parent.rightChild = child;
            }
        }
        
//// Step 4: Case 3 — Node with two children
//        Set SUCCESSOR_PARENT = PTR
//        Set SUCCESSOR = PTR->right
//        While SUCCESSOR->left ≠ NULL do
//        SUCCESSOR_PARENT = SUCCESSOR
//        SUCCESSOR = SUCCESSOR->left
//        End While
//        PTR->data = SUCCESSOR->data
//        If SUCCESSOR_PARENT->left = SUCCESSOR then
//        SUCCESSOR_PARENT->left = SUCCESSOR->right
//        Else
//        SUCCESSOR_PARENT->right = SUCCESSOR->right
//        Free SUCCESSOR
//        End Algorithm
    }


    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        BST tree = new BST();

        int choice, value;
        do {
            System.out.println(" \n--MENU-- ");
            System.out.println("1. Insert");
            System.out.println("2. Search");
            System.out.println("3. Display (In order Traversal)");
            System.out.println("4. Display (Pre order Traversal)");
            System.out.println("5. Display (Post order Traversal)");
            System.out.println("6. Display (Level order Traversal)");
            System.out.println("7. Mirror");
            System.out.println("8. Copy Tree");
            System.out.println("9. Display Height");
            System.out.println("0. Exit");
            System.out.print("Enter your choice: ");
            choice = sc.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter value to insert: ");
                    value = sc.nextInt();
                    tree.root = tree.insert(tree.root, value);
                    break;
                case 2:
                    System.out.print("Enter value to search: ");
                    value = sc.nextInt();
                    tree.search(tree.root, value);
                    break;
                case 3:
                    System.out.print("In order Traversal: ");
                    tree.inorder(tree.root);
                    System.out.println();
                    break;
                case 4:
                    System.out.print("Pre order Traversal: ");
                    tree.preorder(tree.root);
                    System.out.println();
                    break;
                case 5:
                    System.out.print("Post order Traversal: ");
                    tree.postorder(tree.root);
                    System.out.println();
                    break;
                case 6:
                    System.out.print("Level order Traversal: ");
                    tree.levelorder(tree.root);
                    System.out.println();
                    break;
                case 7:
                    System.out.println("Mirror");
                    tree.mirror(tree.root);
                    tree.inorder(tree.root);
                    break;
                case 8:
                    System.out.println("Traversing copied tree");
                    BSTNode temp = tree.copyTree(tree.root);
                    tree.inorder(temp);
                    break;
                case 9 :
                    System.out.println("Height of tree : " + tree.height(tree.root));
                    break;
                case 0:
                    System.out.println("Exited the program.");
                    break;
                default:
                    System.out.println("Enter a valid choice.");
            }
        }while(choice != 0);
        sc.close();
    }
}
