import java.util.Scanner;
import java.util.Queue;
import java.util.ArrayDeque;
import java.util.Stack;

class IBSTNode {
    int data;
    IBSTNode left;
    IBSTNode right;

    IBSTNode(int data) {
        this.data = data;
        left = right = null;
    }
}

public class IBST {

    IBSTNode root;

    IBST() {
        root = null;
    }

    void insert(int data) {
        IBSTNode newNode = new IBSTNode(data);

        if (root == null) {
            root = newNode;
            return;
        }

        IBSTNode curr = root, parent = null;

        while (curr != null) {
            parent = curr;
            if (data < curr.data)
                curr = curr.left;
            else if (data > curr.data)
                curr = curr.right;
            else {
                System.out.println("Duplicate not allowed");
                return;
            }
        }

        if (data < parent.data)
            parent.left = newNode;
        else
            parent.right = newNode;
    }

    void search(int key) {
        IBSTNode curr = root;

        while (curr != null) {
            if (key == curr.data) {
                System.out.println("Key found");
                return;
            } else if (key < curr.data)
                curr = curr.left;
            else
                curr = curr.right;
        }
        System.out.println("Key not found");
    }

    void inorder() {
        Stack<IBSTNode> st = new Stack<>();
        IBSTNode curr = root;

        while (curr != null || !st.isEmpty()) {
            while (curr != null) {
                st.push(curr);
                curr = curr.left;
            }
            curr = st.pop();
            System.out.print(curr.data + " ");
            curr = curr.right;
        }
    }

    void preorder() {
        if (root == null)
            return;

        Stack<IBSTNode> st = new Stack<>();
        st.push(root);

        while (!st.isEmpty()) {
            IBSTNode node = st.pop();
            System.out.print(node.data + " ");

            if (node.right != null)
                st.push(node.right);
            if (node.left != null)
                st.push(node.left);
        }
    }

    void postorder() {
        if (root == null)
            return;

        Stack<IBSTNode> s1 = new Stack<>();
        Stack<IBSTNode> s2 = new Stack<>();

        s1.push(root);

        while (!s1.isEmpty()) {
            IBSTNode node = s1.pop();
            s2.push(node);

            if (node.left != null)
                s1.push(node.left);
            if (node.right != null)
                s1.push(node.right);
        }

        while (!s2.isEmpty())
            System.out.print(s2.pop().data + " ");
    }

    void levelorder() {
        if (root == null)
            return;

        Queue<IBSTNode> q = new ArrayDeque<>();
        q.offer(root);

        while (!q.isEmpty()) {
            IBSTNode node = q.poll();
            System.out.print(node.data + " ");

            if (node.left != null)
                q.offer(node.left);
            if (node.right != null)
                q.offer(node.right);
        }
    }

    int height() {
        if (root == null)
            return 0;

        Queue<IBSTNode> q = new ArrayDeque<>();
        q.offer(root);
        int h = 0;

        while (!q.isEmpty()) {
            int size = q.size();
            h++;

            for (int i = 0; i < size; i++) {
                IBSTNode node = q.poll();
                if (node.left != null)
                    q.offer(node.left);
                if (node.right != null)
                    q.offer(node.right);
            }
        }
        return h;
    }

    void mirror() {
        if (root == null)
            return;

        Queue<IBSTNode> q = new ArrayDeque<>();
        q.offer(root);

        while (!q.isEmpty()) {
            IBSTNode node = q.poll();

            IBSTNode temp = node.left;
            node.left = node.right;
            node.right = temp;

            if (node.left != null)
                q.offer(node.left);
            if (node.right != null)
                q.offer(node.right);
        }
    }

    void displayLeafNodes() {
        if (root == null)
            return;

        Stack<IBSTNode> st = new Stack<>();
        st.push(root);

        while (!st.isEmpty()) {
            IBSTNode node = st.pop();

            if (node.left == null && node.right == null)
                System.out.print(node.data + " ");

            if (node.right != null)
                st.push(node.right);
            if (node.left != null)
                st.push(node.left);
        }
    }

    void displayParents() {
        if (root == null)
            return;

        Queue<IBSTNode> q = new ArrayDeque<>();
        q.offer(root);

        while (!q.isEmpty()) {
            IBSTNode node = q.poll();

            if (node.left != null || node.right != null) {
                System.out.print("Parent=" + node.data);
                System.out.print(" Left=" + (node.left != null ? node.left.data : "NULL"));
                System.out.print(" Right=" + (node.right != null ? node.right.data : "NULL"));
                System.out.println();
            }

            if (node.left != null)
                q.offer(node.left);
            if (node.right != null)
                q.offer(node.right);
        }
    }

    void delete(int key) {
        IBSTNode curr = root, parent = null;

        while (curr != null && curr.data != key) {
            parent = curr;
            if (key < curr.data)
                curr = curr.left;
            else
                curr = curr.right;
        }

        if (curr == null) {
            System.out.println("Key not found");
            return;
        }

        if (curr.left == null || curr.right == null) {
            IBSTNode child = (curr.left != null) ? curr.left : curr.right;

            if (parent == null)
                root = child;
            else if (parent.left == curr)
                parent.left = child;
            else
                parent.right = child;
            return;
        }

        IBSTNode succParent = curr;
        IBSTNode succ = curr.right;

        while (succ.left != null) {
            succParent = succ;
            succ = succ.left;
        }

        curr.data = succ.data;

        if (succParent.left == succ)
            succParent.left = succ.right;
        else
            succParent.right = succ.right;
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        IBST tree = new IBST();
        int choice, value;

        do {
            System.out.println("\n1.Insert\n2.Search\n3.Inorder\n4.Preorder\n5.Postorder\n6.Levelorder\n7.Height\n8.Mirror\n9.Display Parents\n10.Display Leaf Nodes\n11.Delete\n0.Exit");
            choice = sc.nextInt();

            switch (choice) {
                case 1:
                    value = sc.nextInt();
                    tree.insert(value);
                    break;
                case 2:
                    value = sc.nextInt();
                    tree.search(value);
                    break;
                case 3:
                    tree.inorder();
                    System.out.println();
                    break;
                case 4:
                    tree.preorder();
                    System.out.println();
                    break;
                case 5:
                    tree.postorder();
                    System.out.println();
                    break;
                case 6:
                    tree.levelorder();
                    System.out.println();
                    break;
                case 7:
                    System.out.println(tree.height());
                    break;
                case 8:
                    tree.mirror();
                    tree.inorder();
                    System.out.println();
                    break;
                case 9:
                    tree.displayParents();
                    break;
                case 10:
                    tree.displayLeafNodes();
                    System.out.println();
                    break;
                case 11:
                    value = sc.nextInt();
                    tree.delete(value);
                    break;
            }
        } while (choice != 0);

        sc.close();
    }
}

